# AAA v0.6 Orphaned Asset Check Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement an Orphaned Asset Check in `aaa-evals` so any governance file not listed in `index.json` fails CI, with actionable `suggested_fix` output.

**Architecture:** Add a standalone check in `runner/checks/check_orphaned_assets.py` that scans whitelisted governance directories using cross-platform globbing, compares actual files to `index.json`, and returns structured results. Wire it into `run_repo_checks.py`, add eval suite/cases/fixtures, and update CI workflow to enforce.

**Tech Stack:** Python 3, unittest, pathlib, glob, JSON.

### Task 1: Core check logic

**Files:**
- Create: `runner/checks/check_orphaned_assets.py`
- Test: `runner/tests/test_check_orphaned_assets.py`

**Step 1: Write the failing test**

```python
import json
import tempfile
from pathlib import Path

from runner.checks.check_orphaned_assets import check_orphaned_assets


def _write_index(dir_path: Path, paths: list[str]) -> None:
    payload = {"files": [{"path": item} for item in paths]}
    (dir_path / "index.json").write_text(json.dumps(payload), encoding="utf-8")


def test_orphaned_assets_detects_missing_index():
    with tempfile.TemporaryDirectory() as tmp:
        base = Path(tmp) / "docs" / "adrs"
        base.mkdir(parents=True)
        (base / "001.md").write_text("# ADR", encoding="utf-8")
        result = check_orphaned_assets({
            "target_paths": [str(base)],
            "file_pattern": "*.md",
            "exclude_patterns": ["**/README.md", "**/index.json", ".*"],
            "require_index": True,
        })
        assert result["pass"] is False
        assert any(item["type"] == "missing_index" for item in result["details"])


def test_orphaned_assets_detects_orphaned_files_with_fix():
    with tempfile.TemporaryDirectory() as tmp:
        base = Path(tmp) / "docs" / "adrs"
        base.mkdir(parents=True)
        (base / "001.md").write_text("# ADR", encoding="utf-8")
        _write_index(base, ["002.md"])
        result = check_orphaned_assets({
            "target_paths": [str(base)],
            "file_pattern": "*.md",
            "exclude_patterns": ["**/README.md", "**/index.json", ".*"],
            "require_index": True,
        })
        assert result["pass"] is False
        orphaned = [item for item in result["details"] if item["type"] == "orphaned_asset"]
        assert orphaned
        assert "suggested_fix" in orphaned[0]
```

**Step 2: Run test to verify it fails**

Run: `python3 -m unittest runner.tests.test_check_orphaned_assets -v`
Expected: FAIL with `ModuleNotFoundError` or missing function.

**Step 3: Write minimal implementation**

```python
from __future__ import annotations

import json
from pathlib import Path
from typing import Any
import fnmatch
import glob

DEFAULT_EXCLUDES = ["**/README.md", "**/index.json", ".*", "**/.DS_Store"]
DEFAULT_TARGETS = ["**/docs/adrs", "**/docs/milestones", "**/reports"]


def _match_any(path: str, patterns: list[str]) -> bool:
    return any(fnmatch.fnmatch(path, pattern) for pattern in patterns)


def _iter_target_dirs(root: Path, patterns: list[str]) -> list[Path]:
    dirs: list[Path] = []
    for pattern in patterns:
        for hit in glob.glob(str(root / pattern), recursive=True):
            path = Path(hit)
            if path.is_dir():
                dirs.append(path)
    return sorted(set(dirs))


def check_orphaned_assets(config: dict[str, Any]) -> dict[str, Any]:
    root = Path(config.get("repo_root", Path.cwd()))
    targets = config.get("target_paths", DEFAULT_TARGETS)
    excludes = config.get("exclude_patterns", DEFAULT_EXCLUDES)
    file_pattern = config.get("file_pattern", "*.md")
    require_index = config.get("require_index", True)

    details: list[dict[str, Any]] = []
    target_dirs = _iter_target_dirs(root, targets)

    for directory in target_dirs:
        index_path = directory / "index.json"
        if require_index and not index_path.exists():
            details.append({
                "type": "missing_index",
                "path": str(index_path),
                "suggested_fix": "Run `aaa run ops/reindex-all-assets` to update index.json",
            })
            continue

        expected = set()
        if index_path.exists():
            payload = json.loads(index_path.read_text(encoding="utf-8"))
            for entry in payload.get("files", []):
                rel = str(entry.get("path", ""))
                if rel:
                    expected.add(rel)

        actual = set()
        for path in directory.rglob(file_pattern):
            rel = path.relative_to(directory).as_posix()
            if _match_any(rel, excludes) or _match_any(path.as_posix(), excludes):
                continue
            actual.add(rel)

        for orphan in sorted(actual - expected):
            details.append({
                "type": "orphaned_asset",
                "path": str(directory / orphan),
                "suggested_fix": "Run `aaa run ops/reindex-all-assets` to update index.json",
            })

    return {"pass": not details, "details": details}
```

**Step 4: Run test to verify it passes**

Run: `python3 -m unittest runner.tests.test_check_orphaned_assets -v`
Expected: PASS

**Step 5: Commit**

```bash
git add runner/checks/check_orphaned_assets.py runner/tests/test_check_orphaned_assets.py
git commit -m "feat: add orphaned assets check"
```

### Task 2: Integrate check into runner

**Files:**
- Modify: `runner/run_repo_checks.py`

**Step 1: Write the failing test**

Add a small unit test in `runner/tests/test_run_repo_checks.py` (or create if missing) to assert that `--check orphaned_assets` is accepted and returns expected structure for a fixture repo.

**Step 2: Run test to verify it fails**

Run: `python3 -m unittest runner.tests.test_run_repo_checks -v`
Expected: FAIL until dispatch is wired (create test module if missing).

**Step 3: Write minimal implementation**

- Create `runner/tests/test_run_repo_checks.py` if missing
- Import `check_orphaned_assets`
- Add handler for `orphaned_assets`
- Default config:
  - `target_paths`: `['**/docs/adrs', '**/docs/milestones', '**/reports']`
  - `exclude_patterns`: `['**/README.md', '**/index.json', '.*', '**/.DS_Store']`
  - `file_pattern`: `*.md`
  - `require_index`: `True`
- Pass `repo_root` explicitly to ensure deterministic path resolution

**Step 4: Run test to verify it passes**

Run: `python3 -m unittest runner.tests.test_run_repo_checks -v`
Expected: PASS

**Step 5: Commit**

```bash
git add runner/run_repo_checks.py runner/tests/test_run_repo_checks.py
git commit -m "feat: wire orphaned assets check"
```

### Task 3: Add eval suite + fixtures

**Files:**
- Create: `evals/cases/orphaned_assets.jsonl`
- Create: `evals/suites/orphaned_assets.yml`
- Create: `evals/baselines/orphaned_assets.baseline.json`
- Create: `runner/tests/fixtures/orphaned_assets/clean/docs/adrs/index.json`
- Create: `runner/tests/fixtures/orphaned_assets/clean/docs/adrs/001.md`
- Create: `runner/tests/fixtures/orphaned_assets/dirty/docs/adrs/index.json`
- Create: `runner/tests/fixtures/orphaned_assets/dirty/docs/adrs/001.md`

**Step 1: Write the failing eval case**

```json
{"id":"orphaned-clean","repo":"runner/tests/fixtures/orphaned_assets/clean","expected_pass":true}
{"id":"orphaned-dirty","repo":"runner/tests/fixtures/orphaned_assets/dirty","expected_pass":false}
```

**Step 2: Run eval suite to see failures**

Run: `python3 runner/run_repo_checks.py --check orphaned_assets --repo runner/tests/fixtures/orphaned_assets/dirty`
Expected: FAIL with `orphaned_asset` in details.

**Step 3: Wire suite + baseline**

- `evals/suites/orphaned_assets.yml` maps to `orphaned_assets` check
- Baseline captures expected pass/fail counts

**Step 4: Commit**

```bash
git add evals/cases/orphaned_assets.jsonl evals/suites/orphaned_assets.yml evals/baselines/orphaned_assets.baseline.json runner/tests/fixtures/orphaned_assets
git commit -m "feat: add orphaned assets eval suite"
```

### Task 4: CI enforcement (centralized)

**Files:**
- Modify: `aaa-actions/.github/workflows/eval.yml`
- Create: `aaa-evals/.github/workflows/ci.yml`

**Step 1: Add orphaned_assets to central eval workflow**

Append to existing suite run list in `aaa-actions/.github/workflows/eval.yml` (keep deterministic ordering).

**Step 2: Add local workflow to invoke reusable eval**

Create `aaa-evals/.github/workflows/ci.yml` to call the reusable workflow in `aaa-actions`.

**Step 3: Verify workflow format**

Run: `python3 -m yaml aaa-actions/.github/workflows/eval.yml` (or equivalent lint if available)

**Step 4: Commit**

```bash
git add aaa-actions/.github/workflows/eval.yml aaa-evals/.github/workflows/ci.yml
git commit -m "ci: enforce orphaned assets check"
```
